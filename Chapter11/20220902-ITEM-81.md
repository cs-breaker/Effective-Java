# [아이템 81]wait와 notify보다는 동시성 유틸리티를 애용하라

작성자: 박성민

작성일: 2022년 8월 25일

---

wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.

## 동시성 컬렉션

- List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션
- 동기화를 각자의 내부에서 수행한다.
- 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.
  - 여러 기본 동작을 하나의 원자적 동작으로 묶는 ‘상태 의존적 수정’ 메서드들이 추가됨.
    - ex) `Map의 putIfAbsent(k, v)` 이 메서드 덕에 스레드 안전한 정규화 맵을 쉽게 구현할 수 있다.
- `ConcurrentHashMap`은 `get` 같은 검색 기능에 최적화되었기 때문에 get을 먼저 호출한 다음 필요할 때만 `putIfAbsent`를 호출하면 더 빠르다.
- `ConcurrentHashMap` 은 동시성이 뛰어나며 속도도 무척 빠르다.
- 동시성 컬렉션은 동기화한 컬렉션을 낡은 유산으로 만들어버렸다.
  - `Collections.synchronizedMap`보다는 `ConcurrentHashMap`을 사용하는 게 훨씬 좋다.

## 동기화 장치

- 동기화 장치는 스레드가 다른 스레드를 기다릴 수 있게 하여, 서로 작업을 조율할 수 있게 해준다.
- 가장 자주 쓰이는 동기화 장치는 CountDownLatch와 Semaphore이다.
- 가장 강력한 동기화 장치는 Phaser다.

### CountDownLatch

- 일회성 장벽으로, 하나 이상의 스레드가 또 다른 하나 이상의 스레드 작업이 끝날 때까지 기다리게 한다.

시간 간격을 잴 때는 항상 `System.currentTimeMillis`가 아닌 `System.nanoTime`을 사용하자

## wait와 notify

- 새로운 코드라면 wait와 notify가 아닌 동시성 유틸리티를 써야 한다.
- 하지만 레거시 코드에서는 wait와 notify를 다뤄야 할 때도 있다.
- wait 메서드는 스레드가 어떤 조건이 충족되기를 기다리게 할 때 사용한다. 락 객체의 wait 메서드는 반드시 그 객체를 잠근 동기화 영역 안에서 호출해야 한다.
- wait 메서드를 사용할 때는 반드시 대기 반복문(wait loop) 관용구를 사용하라. 반복문 밖에서는 절대로 호출하지 말자.
- notify는 스레드 하나만 깨우며, notifyAll은 모든 스레드를 깨운다. 일반적으로 언제나 notifyAll을 사용하라는 게 합리적이고 안전한 조언이 된다.

## 정리

- 코드를 새로 작성한다면 wait와 notify를 쓸 이유가 없다. 이들을 사용해야 하는 상황이라면 wait는 항상 표준 관용구에 따라 while문 안에서 호출하도록 하자.
- 일반적으로 notify보다는 notifyAll을 사용해야 한다.
