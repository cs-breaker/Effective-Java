# [아이템 84] 프로그램의 동작을 스레드 스케줄러에 기대지 말라

작성자: 박성민

작성일: 2022년 9월 8일

---

여러 스레드가 실행 중이면 운영체제의 스레드 스케줄러가 어떤 스레드를 얼마나 오래 실행할지 정한다. 구체적인 스케줄링 정책은 운영체제마다 다를 수 있다.

정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

## 이식성 좋은 프로그램

- 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이다.
- 실행 준비가 된 스레드들은 맡은 작업을 완료할 때까지 계속 실행되도록 만들자.
- 대기 중인 스레드는 실행 가능하지 않다.

## 실행 가능한 스레드

- 실행 가능한 스레드 수를 적게 유지하는 주요 기법은 각 스레드가 무언가 유용한 작업을 완료한 후에는 다음 일거리가 생길 때까지 대기하도록 하는 것이다.
- 스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안 된다.

## 바쁜 대기

- 스레드는 절대 바쁜 대기 상태가 되면 안 된다.
- 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안 된다는 뜻이다.
- 바쁜 대기는 스레드 스케줄러의 변덕에 취약할 뿐 아니라, 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회를 박탈한다.

```java
// 끔찍한 CountDownLatch 구현 - 바쁜 대기 버전
public class SlowCountDownLatch {
  private int count;

  public SlowCountDownLatch(int count) {
    if (count < 0)
      throw new IllegalArgumentException(count + " < 0");
    this.count = count;
  }

  public void await() {
    while (true) {
      synchronized(this) {
        if (count == 0)
          return;
      }
    }
  }
  public synchronized void countDown() {
    if (count != 0)
      count--;
  }
}
```

- 하나 이상의 스레드가 필요도 없이 실행 가능한 상태인 시스템은 흔하게 볼 수 있다. 이런 시스템은 성능과 이식성이 떨어질 수 있다.

## Thread.yield

- yield 메소드를 호출한 스레드는 실행 대기 상태로 돌아가고 동일한 우선순위 또는 높은 우선순위를 갖는 다른 스레드가 실행 기회를 가질 수 있도록 해준다.
- 특정 스레드가 다른 스레드들과 비교해 CPU 시간을 충분히 얻지 못해서 간신히 돌아가는 프로그램을 보더라도 Thread.yield를 써서 문제를 해결하려는 유혹을 떨쳐내자.
- 증상은 호전되더라도 이식성은 좋지 않다.
- Thread.yield는 테스트할 수단도 없다.

## 정리

- 프로그램의 동작을 스레드 스케줄러에 기대지 말자. 견고성과 이식성을 모두 해치는 행위다.
- 같은 이유로 Thread.yield와 스레드 우선순위에 의존해서도 안 된다.
- 스레드 우선순위는 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 쓰일 수는 있지만, 간신히 동작하는 프로그램을 ‘고치는 용도’로 사용해서는 절대 안 된다.
