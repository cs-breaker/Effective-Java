# [아이템 44]표준 함수형 인터페이스를 사용하라

작성자: 박성민

작성일: 2022년 6월 18일

---

## 람다와 API 모범 사례

- 람다가 지원되면서 API를 작성하는 모범 사례도 크게 바뀌었다.
- 상위 클래스의 기본 메서드를 재정의해 원하는 동작을 구현하는 템플릿 메서드 패턴의 매력이 크게 줄었다.
- 현대적인 해법은 같은 효과의 함수 객체를 받는 정적 팩터리나 생성자를 제공하는 것이다. 즉 함수 객체를 매개변수를 받는 것이다.

## 표준 함수형 인터페이스

- `java.util.function` 패키지를 보면 다양한 용도의 표준 함수형 인터페이스가 담겨 있다.
- 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하자.
  - API가 다루는 개념의 수가 줄어들어 익히기 더 쉬워진다.
  - 표준 함수형 인터페이스들은 유용한 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호운용성도 크게 좋아질 것이다.
- `java.util.function` 패키지에는 총 43개의 인터페이스 담겨 있다. 이 중 기본 인터페이스 6개만 기억하면 나머지를 충분히 유추해 낼 수 있다.

### java.util.function 패키지의 기본 인터페이스 6가지

- `Operatr` 인터페이스는 인수가 1개인 `UnaryOperator`와 2개인 `BinaryOperator`로 나뉘며, 반환값과 인수의 타입이 같은 함수를 뜻한다.
- `Predicate` 인터페이스는 인수 하나를 받아 `boolean`을 반환하는 함수를 뜻한다.
- `Function` 인터페이스는 인수와 반환 타입이 다른 함수를 뜻한다.
- `Supplier` 인터페이스는 인수를 받지 않고 값을 반환(혹은 제공)하는 함수를 뜻한다.
- `Consumer` 인터페이스는 인수를 하나 받고 반환값은 없는(특히 인수를 소비하는) 함수를 뜻한다.

### 기본 인터페이스의 변형

- 기본 인터페이스는 기본 타입인 `int`, `long`, `double`용으로 각 3개씩 변형이 생겨난다.
  - 이름을 기본 인터페이스 앞에 해당 기본 타입 이름을 붙여 지었다.
  - ex) `int`를 받는 `Predicate`는 `IntPredicate`
- 유일하게 Function의 변형만 매개변수화됐다. 정확히는 반환 타입만 매개변수화.
  - ex) `LongFunction<int[]>`은 `long` 인수를 받아 `int[]`을 반환한다.
- `Function` 인터페이스에는 기본 타입을 반환하는 변형이 총 9개가 더 있다.
- 입력과 결과 타입이 모두 기본 타입이라면 접두어로 `SrcToResult`를 사용한다.(총 6개)
  - ex) `LongToIntFunction` : `long`을 받아 `int`를 반환
- 나머지는 입력이 객체 참조이고 결과가 `int`, `long`, `double`인 변형들로, 앞서와 달리 입력을 매개변수화하고 접두어로 `ToResult`를 사용한다. (총 3개)
  - ex) `ToLongFunction<int[]>` : `int[]` 인수를 받아 `long`을 반환한다.
- 인수를 2개씩 받는 변형도 있다.
  - `Bipredicate<T,U>`
  - `BiFunction<T,U,R>`
  - `BiConsumer<T,U>`
- 표준 함수형 인터페이스 대부분은 기본 타입만 지원한다. 그렇다고 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자.
  - 동작은 하지만 “박싱된 기본 타입 대신 기본 타입을 사용하라”라는 아이템 61의 조언을 위배한다.
  - 특히 계산량이 많을 때는 성능이 처참히 느려질 수 있다.

## 언제 표준 함수형 인터페이스를 사용하지 않고 코드를 직접 작성할까?

- 표준 인터페이스 중 필요한 용도에 맞는 게 없다면 직접 작성해야 한다.
  - ex) 매개변수 3개를 받는 `Predicate`
- 그런데 구조적으로 똑같은 표준 함수형 인터페이스가 있더라도 직접 작성해야만 할 때가 있다.
- `Comparator<T>` 인터페이스를 떠올려보자.
  - 구조적으로는 `ToIntBiFunction<T,U>`와 동일하다.
  - 하지만 `ToIntBiFunction<T,U>` 인터페이스가 먼저 나왔더라도 사용하면 안 됐다.
  - 다음의 3가지 특성 중 하나 이상을 만족한다면 전용 함수형 인터페이스를 구현해야 하는 건 아닌지 진중히 고민해야 한다.
    - 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
    - 반드시 따라야 하는 규약이 있다.
    - 유용한 디폴트 메서드를 제공할 수 있다.

## @FunctionalInterface 애너테이션

- 이 애너테이션을 사용하는 이유는 `@Override`를 사용하는 이유와 비슷하다.
- 프로그래머의 의도를 명시하는 것으로, 크게 세 가지 목적이 있다.
  - 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
  - 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
  - 그 결과 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.
- 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하자.

## 함수형 인터페이스를 API에서 사용할 때의 주의점

- 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안 된다.
  - 클라이언트에게 불필요한 모호함만 안겨준다.
  - 이 모호함으로 실제로 문제가 일어난다.

## 정리

- API를 설계할 때 람다를 염두에 두어야 한다.
- 입력값과 반환값에 함수형 인터페이스 타입을 활용하자.
- 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이나, 흔치 않게 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을 수도 있다.
